package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"net"
	"path/filepath"
	"sync"

	serviceconfigv1 "go.einride.tech/grpc-service-config/gen/einride/serviceconfig/v1"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/pluginpb"
)

const docURL = "https://github.com/grpc/grpc/blob/master/doc/service_config.md"

func main() {
	var (
		flags    flag.FlagSet
		path     = flags.String("path", "", "input path of service config JSON files")
		validate = flags.Bool("validate", false, "validate service configs")
		required = flags.Bool("required", false, "require every service to have a service config")
	)
	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		p, err := newPlugin(gen, *path)
		if err != nil {
			return err
		}
		if *validate {
			if err := p.validate(*required); err != nil {
				return err
			}
		}
		return p.generateFromProto()
	})
}

type plugin struct {
	gen   *protogen.Plugin
	files *protoregistry.Files
	path  string
}

func newPlugin(gen *protogen.Plugin, path string) (*plugin, error) {
	var files protoregistry.Files
	for _, file := range gen.Files {
		if err := files.RegisterFile(file.Desc); err != nil {
			return nil, err
		}
	}
	return &plugin{
		gen:   gen,
		path:  path,
		files: &files,
	}, nil
}

func (p *plugin) generateFromProto() error {
	generatedPackages := map[protoreflect.FullName]bool{}
	for _, file := range p.gen.Files {
		if !file.Generate {
			continue
		}
		defaultServiceConfig := proto.GetExtension(
			file.Proto.GetOptions(),
			serviceconfigv1.E_DefaultServiceConfig,
		).(*serviceconfigv1.ServiceConfig)
		if defaultServiceConfig == nil {
			continue
		}
		if generatedPackages[file.Desc.Package()] {
			return fmt.Errorf("package %s has multiple default_service_config annotations", file.Desc.Package())
		}

		jsonServiceConfig, err := protojson.MarshalOptions{
			Multiline: true,
		}.Marshal(defaultServiceConfig)
		if err != nil {
			return err
		}

		var formattedServiceConfig bytes.Buffer
		if err := json.Indent(&formattedServiceConfig, jsonServiceConfig, "", "  "); err != nil {
			return err
		}

		generatedPackages[file.Desc.Package()] = true
		g := p.gen.NewGeneratedFile(
			filepath.Dir(file.GeneratedFilenamePrefix)+
				"/"+string(file.Desc.Package().Parent().Name())+
				"_grpc_service_config.pb.go",
			file.GoImportPath,
		)
		g.P("// Code generated by protoc-gen-go-grpc-service-config. DO NOT EDIT.")
		g.P("package ", file.GoPackageName)
		g.P()
		g.P("// DefaultServiceConfig is the default service config for all services in the package.")
		g.P("// Source: ", file.Desc.Path(), ".")
		g.P("const DefaultServiceConfig = `", formattedServiceConfig.String(), "`")
	}
	return nil
}

func (p *plugin) validate(required bool) error {
	addr, cleanup, err := p.startLocalServer()
	if err != nil {
		return err
	}
	defer cleanup()
	for _, file := range p.gen.Files {
		if !file.Generate {
			continue
		}
		for _, service := range file.Services {
			serviceConfig, ok, err := p.resolveServiceConfig(service)
			if err != nil {
				return err
			}
			if !ok && required {
				return fmt.Errorf(
					"validate: missing service config for %s (see: %s)",
					service.Desc.FullName(),
					docURL,
				)
			}
			// gRPC Go validates a service config when dialing.
			conn, err := grpc.NewClient(
				addr,
				grpc.WithDefaultServiceConfig(serviceConfig),
				grpc.WithTransportCredentials(insecure.NewCredentials()),
			)
			if err != nil {
				return fmt.Errorf("validate: invalid service config for %s: %w", service.Desc.FullName(), err)
			}
			if err := conn.Close(); err != nil {
				return err
			}
			var serviceConfigContent serviceConfigJSON
			if err := json.Unmarshal([]byte(serviceConfig), &serviceConfigContent); err != nil {
				return err
			}
			if required && !serviceConfigContent.hasService(service) {
				return fmt.Errorf(
					"validate: missing service config for %s (see: %s)",
					service.Desc.FullName(),
					docURL,
				)
			}
		}
	}
	return nil
}

func (p *plugin) resolveServiceConfig(service *protogen.Service) (string, bool, error) {
	var serviceConfig *serviceconfigv1.ServiceConfig
	p.files.RangeFilesByPackage(service.Desc.ParentFile().Package(), func(file protoreflect.FileDescriptor) bool {
		serviceConfig = proto.GetExtension(
			file.Options(),
			serviceconfigv1.E_DefaultServiceConfig,
		).(*serviceconfigv1.ServiceConfig)
		return serviceConfig == nil
	})
	if serviceConfig == nil {
		return "", false, nil
	}
	return protojson.Format(serviceConfig), true, nil
}

type serviceConfigJSON struct {
	MethodConfigs []struct {
		Names []struct {
			Service string
			Method  string
		} `json:"name"`
	} `json:"methodConfig"`
}

func (c serviceConfigJSON) hasService(service *protogen.Service) bool {
	for _, methodConfig := range c.MethodConfigs {
		for _, name := range methodConfig.Names {
			if (name.Service == "" && name.Method == "") ||
				(name.Service == string(service.Desc.FullName()) && name.Method == "") {
				return true
			}
		}
	}
	return false
}

func (p *plugin) startLocalServer() (string, func(), error) {
	lis, err := net.Listen("tcp", "localhost:0")
	if err != nil {
		return "", nil, err
	}
	localServer := grpc.NewServer()
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		_ = localServer.Serve(lis)
	}()
	cleanup := func() {
		localServer.Stop()
		wg.Wait()
	}
	return lis.Addr().String(), cleanup, nil
}
